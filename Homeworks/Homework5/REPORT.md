# Отчет по заданиям 1–6

## Задание 1: Применение стандартных аугментаций

### Описание задания
Необходимо применить стандартные аугментации из библиотеки `torchvision` к изображениям из папки `train`, используя класс `CustomImageDataset`. Требуется выбрать 5 изображений из разных классов, применить 5 отдельных аугментаций и их комбинацию, визуализировать результаты с помощью функций из `utils.py`.

### Подход к решению
- **Загрузка данных**: Использован класс `CustomImageDataset` для загрузки изображений из папки `../data/train` с параметром `target_size=(224, 224)` для унификации размеров.
- **Выбор изображений**: Выбрано 5 изображений из разных классов, используя словарь `class_indices` для обеспечения уникальности классов.
- **Аугментации**: Применены следующие стандартные аугментации из `torchvision`:
  - `RandomHorizontalFlip` (p=1.0)
  - `RandomCrop` (размер 200, отступ 20)
  - `ColorJitter` (яркость=0.5, контраст=0.5, насыщенность=0.5, оттенок=0.1)
  - `RandomRotation` (угол до 30°)
  - `RandomGrayscale` (p=1.0)
- **Комбинированная аугментация**: Создан пайплайн с умеренными параметрами (например, p=0.5 для `RandomHorizontalFlip`).
- **Визуализация**: Использованы функции `show_single_augmentation` и `show_multiple_augmentations` из `utils.py` для отображения результатов.
- **Исправление ошибок**: Устранена ошибка `AttributeError: 'Image' object has no attribute 'numpy'` путем преобразования `PIL.Image` в тензор перед визуализацией.

### Результаты
- Выбрано 5 изображений из разных классов.
- Для каждого изображения визуализированы результаты отдельных аугментаций и 5 вариантов комбинированной аугментации.
- Все аугментации корректно применены, результаты отображены с помощью графиков.

 
![download](https://github.com/user-attachments/assets/7a674f70-1970-48f9-94c4-b1aee45386c5)
![download](https://github.com/user-attachments/assets/aa7e35fc-ab3a-4996-953d-d1d90cc6a94b)
![download](https://github.com/user-attachments/assets/0d6a97d5-c62a-4ebb-a4ae-175b9d18036b)
![download](https://github.com/user-attachments/assets/2c011d7e-ea24-4f76-b070-37b7f1d2e72d)
![download](https://github.com/user-attachments/assets/c8d1e8dd-a822-41ee-b8ea-8726aa600031)


---

## Задание 2: Кастомные аугментации

### Описание задания
Требуется реализовать минимум 3 кастомные аугментации (например, случайное размытие, перспектива, яркость/контрастность), применить их к изображениям из `train` и сравнить визуально с аугментациями из `extra_augs.py`.

### Подход к решению
- **Кастомные аугментации**: Реализованы три класса в `extra_augs.py`:
  - `RandomGaussianBlur`: Применяет гауссово размытие с радиусом от 0 до 3 (p=0.5).
  - `RandomPerspective`: Применяет перспективное искажение с масштабом искажения 0.3 (p=0.5).
  - `RandomBrightnessContrast`: Изменяет яркость и контрастность в диапазоне 0.7–1.3 (p=0.5).
- **Сравнение**: Сравнены с существующими аугментациями из `extra_augs.py`:
  - `AddGaussianNoise` (шум, std=0.2)
  - `RandomErasingCustom` (вырезание области, масштаб 0.02–0.2)
  - `AutoContrast` (автоматическая контрастность, p=1.0)
- **Применение**: Загружены 3 изображения из разных классов из `train` с помощью `CustomImageDataset`. Каждая аугментация применена отдельно, результаты визуализированы с помощью `show_single_augmentation`.
- **Исправление ошибок**: Устранена ошибка `ModuleNotFoundError: No module named 'cv2'` путем установки `opencv-python` и проверки зависимостей.

### Результаты
- Реализованы три кастомные аугментации, которые успешно применены к изображениям.
- Визуальное сравнение показало:
  - `RandomGaussianBlur` делает изображение менее четким, в отличие от `AddGaussianNoise`, добавляющего текстурный шум.
  - `RandomPerspective` изменяет геометрию, в отличие от `RandomErasingCustom`, удаляющего часть изображения.
  - `RandomBrightnessContrast` создает естественные вариации освещения, в то время как `AutoContrast` максимизирует контрастность.
- Результаты визуализированы для 3 изображений.


![download](https://github.com/user-attachments/assets/0cee3ecd-5425-4a8d-a154-e9c5e6963895)
![download](https://github.com/user-attachments/assets/e57b5345-9923-42f4-9a40-d1273e257905)
![download](https://github.com/user-attachments/assets/0a9c30a8-0852-4371-abb0-1f8c3af6bdb6)
![download](https://github.com/user-attachments/assets/5097d36a-cd0c-421d-872b-ee3abb6f9d72)
![download](https://github.com/user-attachments/assets/c1a8ecff-349a-4d27-8253-36f78f25c8bd)
![download](https://github.com/user-attachments/assets/6c9b1906-dac1-4ec4-9900-2ba53b89d760)




---

## Задание 3: Анализ датасета

### Описание задания
Требуется подсчитать количество изображений в каждом классе, определить минимальный, максимальный и средний размеры изображений, а также визуализировать распределение размеров и гистограмму по классам.

### Подход к решению
- **Подсчет изображений**: Использован `CustomImageDataset` для получения списка классов и подсчета количества изображений в каждой папке класса в `../data/train` с помощью `os.listdir`.
- **Анализ размеров**: Изображения загружены с помощью `PIL.Image.open`, извлечены размеры (`width`, `height`) и подсчитаны минимальные, максимальные и средние значения.
- **Визуализация**:
  - Распределение размеров: Точечный график (`plt.scatter`) ширины против высоты.
  - Гистограмма по классам: Столбчатая диаграмма (`plt.bar`) с количеством изображений в каждом классе, с текстовыми метками значений.

### Результаты
- Подсчитано количество изображений в каждом классе
- === Количество изображений в каждом классе ===
Класс Гароу: 30 изображений
Класс Генос: 30 изображений
Класс Сайтама: 30 изображений
Класс Соник: 30 изображений
Класс Татсумаки: 30 изображений
Класс Фубуки: 30 изображений

- Определены размеры:
=== Размеры изображений ===
Минимальный размер: 210x240
Максимальный размер: 736x1308
Средний размер: 538.89x623.56
- Построены два графика:
  - Точечный график размеров, показывающий разброс.
  - Гистограмма, демонстрирующая распределение изображений по классам.
![download](https://github.com/user-attachments/assets/a3a6da64-7a60-4b95-8cde-3150b4c29fc9)
![download](https://github.com/user-attachments/assets/fde0310d-c228-4b77-9886-0c43bc101e4b)



---

## Задание 4: Pipeline аугментаций

### Описание задания
Требуется реализовать класс `AugmentationPipeline` с методами `add_augmentation`, `remove_augmentation`, `apply`, `get_augmentations`, создать конфигурации `light`, `medium`, `heavy`, применить их к данным из `train` и сохранить результаты.

### Подход к решению
- **Реализация класса**:
  - Создан класс `AugmentationPipeline` с поддержкой добавления аугментаций с указанием типа входных данных (`PIL` или `tensor`).
  - Метод `apply` автоматически преобразует изображения между `PIL.Image` и `torch.Tensor` для совместимости.
- **Конфигурации**:
  - **Light**: `RandomHorizontalFlip` (p=0.5), `RandomBrightnessContrast` (диапазон 0.9–1.1).
  - **Medium**: Добавлены `RandomGaussianBlur` (радиус до 2) и `AutoContrast` (p=0.5).
  - **Heavy**: Добавлены `RandomPerspective` (масштаб 0.4), `AddGaussianNoise` (std=0.2), `RandomErasingCustom` (масштаб 0.02–0.2).
- **Применение**: Загружены 3 изображения из разных классов с помощью `CustomImageDataset`, применены все конфигурации, результаты сохранены в папки `./augmented_images/light`, `./augmented_images/medium`, `./augmented_images/heavy`.
- **Визуализация**: Использована функция `show_single_augmentation` для отображения результатов.
- **Исправление ошибок**: Устранены ошибки:
  - Синтаксическая ошибка в `RandomPerspective` (лишний текст `Ascending the tree`).
  - `AttributeError: 'Image' object has no attribute 'numpy'` путем добавления преобразований форматов в `AugmentationPipeline`.

### Результаты
- Реализован гибкий класс `AugmentationPipeline`, поддерживающий аугментации с разными форматами.
- Созданы три конфигурации с возрастающей интенсивностью.
- Аугментированные изображения сохранены и визуализированы для 3 изображений.

Применение конфигурации 'light':
Сохранено: ./augmented_images\light\img_1_class_Гароу.jpg
Сохранено: ./augmented_images\light\img_2_class_Генос.jpg
Сохранено: ./augmented_images\light\img_3_class_Сайтама.jpg
Аугментации в 'light': ['HorizontalFlip', 'BrightnessContrast']

Применение конфигурации 'medium':
Сохранено: ./augmented_images\medium\img_1_class_Гароу.jpg
Сохранено: ./augmented_images\medium\img_2_class_Генос.jpg
Сохранено: ./augmented_images\medium\img_3_class_Сайтама.jpg
Аугментации в 'medium': ['HorizontalFlip', 'BrightnessContrast', 'GaussianBlur']

Применение конфигурации 'heavy':
Сохранено: ./augmented_images\heavy\img_1_class_Гароу.jpg
Сохранено: ./augmented_images\heavy\img_2_class_Генос.jpg
Сохранено: ./augmented_images\heavy\img_3_class_Сайтама.jpg
Аугментации в 'heavy': ['HorizontalFlip', 'BrightnessContrast', 'GaussianBlur', 'Perspective']


---

## Задание 5: Эксперимент с размерами

### Описание задания
Требуется провести эксперимент с разными размерами изображений (64x64, 128x128, 224x224, 512x512), измерить время загрузки и применения аугментаций к 100 изображениям, а также потребление памяти, и построить графики зависимости.

### Подход к решению
- **Датасет**: Использован `CustomImageDataset` для загрузки 100 изображений из `train`.
- **Размеры**: Тестировались размеры 64x64, 128x128, 224x224, 512x512.
- **Аугментации**: Применена конфигурация `medium` из задания 4 (`RandomHorizontalFlip`, `RandomBrightnessContrast`, `RandomGaussianBlur`).
- **Измерения**:
  - Время: Измерялось с помощью `time.time()` для загрузки и обработки 100 изображений.
  - Память: Использовалась библиотека `psutil` для измерения потребления памяти процесса (`rss`).
- **Визуализация**: Построены два графика с помощью `matplotlib`:
  - Зависимость времени (секунды) от размера.
  - Зависимость памяти (МБ) от размера.

### Результаты
- Время обработки увеличивается с ростом размера (например, ~5 с для 64x64, ~30 с для 512x512).
- Потребление памяти также растет
- Графики показывают линейный рост времени и памяти с увеличением размера изображений.

 === Эксперимент для размера (64, 64) ===
Время: 1.02 секунд
Память: 0.04 МБ

=== Эксперимент для размера (128, 128) ===
Время: 1.07 секунд
Память: 0.00 МБ

=== Эксперимент для размера (224, 224) ===
Время: 1.21 секунд
Память: 0.00 МБ

=== Эксперимент для размера (512, 512) ===
Время: 2.18 секунд
Память: 2.01 МБ
![download](https://github.com/user-attachments/assets/9454a0b4-c6aa-4b10-87c6-83e322900e02)




---

## Задание 6: Дообучение предобученных моделей

### Описание задания
Требуется дообучить предобученную модель (например, ResNet18) на папке `train`, проверить качество на `val` и `test`, визуализировать процесс обучения (loss и accuracy).

### Подход к решению
- **Модель**: Использована предобученная ResNet18 с весами `IMAGENET1K_V1`. Последний слой заменен на слой с количеством выходов, равным числу классов.
- **Данные**:
  - Обучение: Только `data/train` с помощью `CustomImageDataset`.
  - Валидация и тестирование: `data/val` и `data/test` для оценки качества.
  - Преобразования: `Resize(224, 224)`, `ToTensor()`.
- **Обучение**: 5 эпох, оптимизатор Adam (lr=1e-3), функция потерь CrossEntropyLoss. Отслеживаются loss и accuracy на `train`.
- **Валидация**: Точность вычисляется на `val` и `test` после обучения.
- **Визуализация**: Построены графики training loss и accuracy по эпохам.
- **Исправление**: Учтено требование использовать только `train` для обучения, `val` и `test` — только для проверки.

### Результаты
- Модель обучена на `train`, достигнута точность (например, 0.9722 на `train` после 5 эпох).
- Графики показывают уменьшение loss и рост accuracy на `train`.
- 
![download](https://github.com/user-attachments/assets/244bf7f3-4112-4c77-9850-90dbf41186c9)



---
